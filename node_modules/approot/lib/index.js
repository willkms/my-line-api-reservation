(function() {
  var approot, categorizeArg, consolidate, consolidateArray, consolidateDepth, consolidateObject, exports, fs, isBrowser, listChildren, pathUtil, relativeRequire,
    slice = [].slice;

  isBrowser = typeof window !== 'undefined';

  if (isBrowser) {
    fs = require('./fakeFS');
  } else {
    fs = require('fs');
  }

  pathUtil = require('path');

  approot = function() {
    var path, rootPath, rootpath;
    rootPath = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    path = pathUtil.resolve.apply(pathUtil, rootPath);
    rootpath = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return pathUtil.resolve(path, pathUtil.join.apply(null, args));
    };
    rootpath.consolidate = consolidate;
    rootpath.listChildren = listChildren;
    rootpath.require = relativeRequire;
    return rootpath;
  };

  relativeRequire = function() {
    var args, path;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    path = this.apply(this, args);
    return require(path);
  };

  categorizeArg = function(arg) {
    var type;
    if (arg == null) {
      return 'null';
    }
    type = typeof arg;
    switch (type) {
      case 'number':
      case 'string':
      case 'boolean':
        return type;
      case 'object':
        if (Array.isArray(arg)) {
          return 'array';
        } else {
          return 'hash';
        }
    }
  };

  consolidateDepth = function(depth) {
    var ex, file, i, len, path, subfiles;
    if (!(depth > 0)) {
      return this;
    }
    path = this();
    if (fs.existsSync(path)) {
      try {
        subfiles = fs.readdirSync(path);
        for (i = 0, len = subfiles.length; i < len; i++) {
          file = subfiles[i];
          this[file] = approot(path, file);
          consolidateDepth.call(this[file], depth - 1);
        }
      } catch (_error) {
        ex = _error;
        if (ex.code !== 'ENOTDIR') {
          throw ex;
        }
      }
    }
    return this;
  };

  consolidateObject = function(hierarchy) {
    var key, options, path;
    path = this();
    for (key in hierarchy) {
      options = hierarchy[key];
      this[key] = approot(path, key);
      switch (categorizeArg(options)) {
        case 'number':
          consolidateDepth.call(this[key], options);
          break;
        case 'string':
          consolidateArray.call(this[key], [options]);
          break;
        case 'array':
          consolidateArray.call(this[key], options);
          break;
        case 'hash':
          consolidateObject.call(this[key], options);
      }
    }
    return this;
  };

  consolidateArray = function(items) {
    var i, item, len, path;
    path = this();
    for (i = 0, len = items.length; i < len; i++) {
      item = items[i];
      this[item] = approot(path, item);
    }
    return this;
  };

  consolidate = function(options) {
    if (options == null) {
      options = 1;
    }
    switch (categorizeArg(options)) {
      case 'number':
        consolidateDepth.call(this, options);
        break;
      case 'string':
        consolidateArray.call(this, [options]);
        break;
      case 'array':
        consolidateArray.call(this, options);
        break;
      case 'hash':
        consolidateObject.call(this, options);
        break;
      default:
        consolidateDepth.call(this, 1);
    }
    return this;
  };

  listChildren = function() {
    var args, path;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    args.unshift(this());
    path = pathUtil.join.apply(pathUtil, args);
    if (!fs.existsSync(path)) {
      return [];
    }
    return fs.readdirSync(path);
  };

  exports = module.exports = approot;

}).call(this);
